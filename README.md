I have published the original source code from my 1994 C++ book on my GitHub. It's a glimpse into the past. Naturally, it was also interesting to see what changes were necessary to compile it with a modern compiler. Attached is the translation of the README file
https://github.com/adeccscholar/Programming_with_OOP

# Programming with C++
These are the original sources for my book Programming with C++, which was published in the early 1990s by the "Markt & Technik" publishing house. A big thanks to Andreas, who still had the 3.5" disk included with the book, and even a working drive, and both actually functioned! Since I hold the copyrights to the sources and also the distribution rights—since the book was no longer reprinted by the rights successor and I was able to reclaim those rights—I have now released the sources here under the MIT License.

## How this book came about

This was at a time when the internet as we know it today was just being born. When the book was published, less than 1% of global communication ran over the emerging internet. Our knowledge came from books, magazines, conferences, and trade shows, as well as from academic studies. One might think that, at least, this knowledge was from reliable sources. But how did it come to pass that "Markt & Technik" called me one day and asked me to write this book? Yes, you read that correctly. One day in December 1993, the well-known publishing house called me. I had just finished my mathematics degree with a somewhat exotic specialization in "computer science, databases, and data security" and had started my first job as a mathematician at a subsidiary of Colonia Insurance in August. You might think this sounds like a joke. That’s what I thought, too, because at that time, radio stations were just starting to make prank calls, and I assumed this was one of them. But the publisher called again in the evening, asking me to reconsider. My later editor explained how they came across me and why they wanted me to write this particular book.

The backstory involved an article in PC Professional that was supposed to focus on C++ but quickly took on a negative tone, even using the term "elitist" in the title of the series. Moreover, there were significant factual errors. So, I decided to call the editor (back then, there were fewer phones but no call centers, so you could actually reach the people in charge). He told me he wasn’t the author and suggested I write down my points. I ended up writing a two-page letter to the editor. The publisher responded with a standard "thank you" letter but didn’t address my points. More interesting was the author's response, which was accidentally included and dismissed me as a "random student without knowledge." That wasn’t the exact wording—this was 30 years ago—but it sparked a technical debate.

In my reply, I mentioned that I was a "graduate mathematician" and referred to my unique education via a special study contract. Some people like to flaunt their titles, but to me, it’s never been a big deal. A title doesn’t define a person, and this was one of the few times I used it in a letter. The next day, late in the evening (almost night), the phone rang. The author was in the USA at the time but wanted to resolve the situation quickly, and we talked for a long time. I can only imagine what that phone call cost, especially in a time when our parents often reminded us how expensive long phone calls were. Many of the errors in the article stemmed from "text corrections" made by the publisher, a peculiarity of German PC magazines where editors alter technical articles. Changing sentence structure might make it sound better, but in the German language, it can also change the meaning (think of how commas can change life-or-death decisions). There were also genuine mistakes in the text. But back then, arguments were more constructive; such exchanges were seen as opportunities to improve. The goal wasn’t to be right but to learn. And personal attacks were off-limits.

Since the author had written not only articles but also books, he recommended me to the publisher when they were discussing a new C++ book. He later served as one of the reviewers for the book and called it The Other C++ Book because it didn’t follow the general trends. This gave rise to the book’s subtitle.

It also turned out to be a lucrative side income, and when Markt & Technik was eventually acquired by a U.S. company, I even received checks from Paramount. Nowadays, in the age of Lulu and other print-on-demand services, where anyone can write a book, get an ISBN, and sell even unreviewed texts on Amazon, younger people may not understand this. Back then, you needed a publisher to handle the printing and distribution, which they financed upfront. The book was printed in two editions. You had an editor, reviewers, multiple rounds of corrections, and designers for the book cover. Then you’d receive a package with the first two copies, freshly printed, still smelling like new books—a priceless moment.

## Important considerations when reading the source code

Please remember that these are 30-year-old source codes. The book was written four years before the first C++ standard. This was a time before 64-bit systems, somewhere between MS-DOS and Windows 3.1. The world was transitioning from 16-bit to 32-bit systems. Borland C++ 3.1 was one of the few compilers that supported both platforms and could still create DOS programs. At that time, the internet as we know it didn’t exist, Java and everything that followed from it hadn’t yet appeared, and while Linux had been around for two years, it wasn’t widely used on PCs outside academic circles. It was more of a battle between Microsoft and IBM for "supremacy" and the better system.

File names were limited to 8 characters for the name and 3 for the extension, leading to odd abbreviations that seem laughable today. Identifier lengths were also limited, and we often used awkward Denglish (German-English hybrids) because there was less international collaboration in the field back then.

It’s not just that C++ was in its early stages—Stepanov and Meng Lee were just presenting the concepts of the STL (Standard Template Library) to the C++ standards committee. This led to changes in C++, but those developments weren’t available until two years later. It was also a time before a standard library existed. Stroustrup called the lack of a standard library the biggest mistake of C++’s early years, and the concepts of the Boost library hadn’t yet been conceived. Some people may not understand my reactions to academic debates about programming languages, but one must have lived through that era to appreciate the monumental effort behind the development of C and C++.

Let’s consider these sources as a "software museum." Stroustrup once remarked that students today don’t see enough old software. In every other field, knowledge is built on the work of previous generations, but in computer science, younger people often think they’re reinventing everything and disregard historical knowledge. Generally, the sources should still compile with only a few changes, though the development environments of Borland C++ 3.1/4.0, Microsoft Quick C++, and Symantec C++ are hardly usable or available today.

These sources use the Borland C++ compiler, not to be confused with the later C++ Builder. Version 4.0 was released while I was writing the book, and it introduced new features. So, I have provided sources and project files for this version as well.

It’s exciting to see if these pre-standard sources can still be used with modern development systems and what adjustments might be necessary. But that’s the strength of C++—even older code can still be used in modern systems.

## Processing dBase files with C++

As I mentioned earlier, I migrated the dBase sources from the above archive to a current compiler. It was interesting to see if this could be done without major issues and to discover what general problems would arise.

The good news: it’s relatively simple, with just a few strict requirements. One notable difference is the use of the "char*" parameter, which today is usually replaced with "const char*" to prevent changes to constants, especially strings generated by the compiler. The same goes for copy constructors, which are only recognized if written with a "const&" parameter. This also necessitates making some selectors "const," at least when used in copy constructors. Finally, some unsafe methods like "strcpy" are no longer allowed, but you can re-enable them in Visual Studio with "#define _CRT_SECURE_NO_WARNINGS" at the beginning of the file, before including any header files.

The most challenging issue was the absence of the old system date classes from the DOS era, which had to be rewritten from scratch. File streams were also updated during standardization and now have fewer parameters. I’ve added a few methods that should be compatible with C++98.

And lastly, I adjusted the header file names, changing only the ones that had to be updated (e.g., fstream.h to fstream) and always explicitly opening the namespace. While this isn’t a good practice with modern code, back when I wrote the original sources, namespaces didn’t exist (they were introduced around that time), and certainly, there was no standard library.

Enjoy trying it out—I was able to open the generated DBF file in Excel, and all the data was intact.

## Interest Calculations with C

I also transferred the final example from the C section of the book to a current compiler. To remind you, this is less of a pure C program and more about the subset of C++ that pertains to the C language. That’s why the original files were in .cpp format and were compiled with C++. As expected, the necessary adjustments were minor, as C had already been standardized at the time (ANSI X3.159-1989 (C89), ISO/IEC 9899:1990 (C90)). This shows why the close relationship between C and C++ is so important in software development, as many critical computing programs in industries, governments, and financial institutions are written in C. It also highlights the importance of an independent standardization process.

Okay, now to the required changes. First, the "#define _CRT_SECURE_NO_WARNINGS" directive to allow unsafe methods like strchr and strncpy, which aren’t used in the calculation itself but in reading input and handling the comma as a decimal separator. This is where the familiar "char*" issue crops up again. For modern C++, "char*" isn’t allowed in the original context, and direct use of the parameter is prohibited due to the enforcement of "const." So, a copy of the string must be created within the function to be manipulated. I intentionally used the C methods "malloc" and "free" to keep it C-like.

The final change is in the actual calculation section. Today, an explicit cast is required in the "Rate()" function to ensure that the "ZeitWertFaktor()" function is used correctly.

It is quite impressive that the 30-year-old C source code can be used with a modern C++ compiler with almost no changes. This highlights the significance of C++ and the remarkable work done by the volunteers involved in the standardization process.

