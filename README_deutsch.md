# Programmierung mit C++

Dieses sind die ursprünglichen Quellen für mein Buch "Programmierung mit C++", dass Anfang der 90iger Jahre im Verlag "Markt & Technik" erschienen ist. Danke an Andreas, der im Buch die 3.5" Diskette hatte, und sogar noch ein passendes Laufwerk, und beides hat dann sogar noch funktioniert. Da ich ohnehin die Urheberrechte an den Quellen habe, und auch die Verwertungsrechte, da das Buch vom Rechtenachfolger nicht mehr neu aufgelegt wurde, und ich damit die Möglichkeit hatte, diese zurückzufordern, habe ich die Quellen hier unter der MIT Lizenz veröffentlicht.  

## Wie kam es zu diesem Buch

Das war in einer Zeit, in der das Internet in der heutigen Form entstand. Als das Buch erschien, liefen aber nicht mal 1% der weltweiten Kommunikation über das entstehende Internet.  Unser Wissen stammte damit aus Büchern, Zeitschriften, Konferenzen und Messen, und eben aus dem Studium. Jetzt könnte man meinen, dass es damit wenigstens aus seriösen Quellen stammte. Nur wie kam es dazu, dass der Verlag "Markt & Technik" eines Tages bei mir anrief, und mich bat, dieses Buch zu schreiben? Ja, richtig gelesen. Eines Tages im Dezember 1993 rief der bekannte Verlag bei mir an, ich hatte gerade mein Mathematik- Studium mit der exotischen Spezialisierungsrichtung "Informatik, Datenbanken und Datensicherheit" abgeschlossen, und hatte im August meine erste Anstellung als Mathematiker bei einem Ableger der Colonia Versicherung begonnen. Ihr denkt jetzt vielleicht auch, das ist ein Witz. Denn das habe ich auch geglaubt, damals begannen Radio Sender mit solchen Scherzanrufen, und genau dafür habe ich es gehalten. Aber der Verlag rief dann abends noch mal an, und bat mich, es mir doch so überlegen. Und meine spätere Lektorin erklärte mir, wie sie auf mich gekommen sind, und warum ausgerechnet ich dieses Buch schreiben sollte.

Hintergrund war ein Zeitungsartikel bei "PC Professional", in der es vorrangig um C++ gehen sollte, es aber schnell einen negativen Beigeschmack gab, so verwendete schon der Titel der Serie den Begriff "elitär". Aber, es gab eben auch sehr grobe inhaltliche Fehler. Also habe ich mich damals durchgerungen, und den Redakteur angerufen (damals gab es zwar weniger Telefone, aber noch keine Call- Center, also tatsächlich erreichte man die Verantwortlichen noch). Der sagte, er wäre nicht der Autor, ich solle meine Punkte doch aufschreiben. Also schrieb ich einen 2 seitigen Leserbrief. Der Verlag schickte mir dann auch eine Bla Bla Bla Antwort, bedankte sich, aber ging nicht auf die Inhalte an. Interessanter war die Antwort des Autors, die versehentlich beigelegt war, und mich "als hergelaufenen Studenten ohne Wissen" einstufte. Das war nicht die Originalantwort, es ist 30 Jahre her, aber daraus entbrannte ein fachlicher Schlagabtausch.

In der Antwort schrieb ich dann auch "Diplommathematiker" und verwies auf meine einzigartige Ausbildung via eines Sonderstudienvertrags. Einige verweisen ja zu gerne auf Titel, für mich spielte das nur eine geringe Rolle, ein Titel macht niemanden aus, und es war über eine lange Zeit das einzige Mal, dass ich dieses auf einen Brief schrieb. Einen Tag später klingelte am späten Abend  (fast schon nachts) das Telefon, der Autor befand sich gerade in den USA, wollte aber die Situation schnell klären, und wir sprachen lange. Ich möchte nicht wissen, was das Telefongespräch gekostet hat, es war ja auch eine Zeit, wo unsere Eltern uns oft ermahnten, wie teuer es doch ist, lange zu telefonieren. Hintergrund vieler Fehler waren "Textkorrekturen" des Verlages, eine Besonderheit, zumindest in PC Zeitschriften, in Deutschland, Textchefs verändern den Text in Fachartikeln. Und wenn man den Satzbau ändert, dann klingt der Satz vielleicht besser, aber kann in der deutschen Sprache auch ein anderer Sinn ergeben (man erinnere sich an das Komma, dass über Leben und Tod entscheidet). Aber es waren auch einige echte Fehler im Text. Aber damals wurde eben auch noch konstruktiv gestritten, man sah solche Auseinandersetzungen als Chance sich weiterzuentwickeln an, es ging nicht darum am Ende Recht zu behalten. Und schon gar nicht wollte man den Diskussionspartner zerstören, persönliche Angriffe waren tabu. 

Und da der Autor nicht nur Zeitungsartikel, sondern auch einige Bücher geschrieben hatte, sagte er damals dem Verlag, dass sie mich ansprechen sollten, als über ein neues C++ Buch diskutiert wurde, er war später auch einer der Gutachter für das Buch und nannte es "Das andere C++ Buch", weil es nicht der allgemeinen Welle folgte. So entstand der Untertitel zum Buch.

Es war tatsächlich auch ein lohnendes Nebeneinkommen, und da "Mark & Technik" bald von US- Unternehmen übernommen wurde, erhielt ich am Ende sogar Schecks von "Paramount". Und vielleicht verstehen das jüngere im Zeitalter von Lulu und anderen Print on Demand- Diensten nicht mehr, in denen jeder ein Buch schreiben, und sogar eine ISBN- Nummer bekommt, und sogar ungeprüfte Texte über Amazon verkaufen kann. Früher brauchte man einen Verlag, der den Druck und die Verteilung übernahm, alles vorfinanziert. Das Buch wurde damals in 2 Auflagen gedruckt. Man hatte eine Lektorin oder Lektor, es gab Gutachterinnen und Gutachter, mehrere Korrekturen, und Designer die den Buchdeckel entwerfen. Und dann bekommt man Post, da waren die ersten 2 Exemplare drin, Vorabdrucke, die riechen noch richtig nach Buch. Ein unbezahlbarer Moment.

## Bei Lesen der Quellen unbedingt beachten

Bitte beachtet beim Verwenden der Quellen, dass dieses 30 Jahre alte Quelltexte sind. Das Buch wurde 4 Jahre vor dem ersten C++ Standard geschrieben. Das war eine Zeit vor 64bit Systemen, irgendwo zwischen MS DOS und MS Windows 3.1. Die Welt befand sich gerade am Übergang von 16bit zu 32bit, der Borland C++ 3.1 war einer der wenigen Compiler, die beide Plattformen bediente, und auch noch DOS Programme erstellen konnte. Es gab zu diesem Zeitpunkt noch kein Internet, wie wir es heute kennen, es gab offiziell noch kein Java, und alles was daraus folgte, und Linux gab es zwar schon 2 Jahre, hatte aber auf PCs noch so gut wie keine Verbreitung, zumindest nicht außerhalb des akademischen Bereichs. Es war mehr ein Streit zwischen Microsoft und IBM um die "Herrschaft" und das bessere System.

In dieser Zeit gab es auch noch keine langen Dateinamen, diese waren auf 8 Stellen für den Namen, und 3 für die Erweiterung begrenzt. Das führte zwangsläufig zu kruden Abkürzungen, über die wir heute nur lächeln. Auch war die Länge der Bezeichner noch sehr begrenzt, und wir nutzen oft ein heftiges Danglish, der internationale Austausch fehlte im Berufsleben noch. 

Es ist nicht nur so, dass C++ selber sich in einer frühen Entwicklungsphase befand, Stepanow und Meng Lee stellten die Konzepte der STL gerade dem Standardisierungskomitee für C++ vor. Das führte dazu, dass es Änderungen in C++ gab und die Entwicklung gerade begann. Erst 2 Jahre später waren diese dann erstmals verfügbar. Es war auch eine Zeit vor einer Standardbibliothek, Stroustrup bezeichnete das Fehlen einer Standardbibliothek als größten Fehler der Anfangszeit, und auch die Konzepte der boost Bibliothek gab es noch nicht. Einige verstehen meine Reaktion auf die "akademischen" Diskussionen über Programmiersprachen nicht, vielleicht muss man diese Zeit erlebt haben, um zu verstehen, welche Leistung sich hinter der Entwicklung von C und C++ stehen.  

Nehmen wir die Quellen also als ein "Softwaremuseum". Auch dieser Begriff wurde von Stroustrup mal aufgebracht, als er meinte, dass Studierende heute zu wenig alte Software sehen, und in jeder Wissenschaft würde man auf das Wissen der vorherigen Generationen aufbauen, nur in der Informatik glauben die jüngeren all zu oft alles neue zu erfinden und sich über das historische Wissen hinwegzusetzen. Generell sollten sie aber mit wenigen Änderungen noch kompilierbar sein, wenn auch die damals verwendeten Entwicklungssysteme Borland C++ 3.1/4.0, Microsoft Quick C++ und Symantec C++ kaum noch lauffähig oder verfügbar sein sollten. 

Es handelt sich auch um den Borland C++ Compiler, nicht mit dem späteren C++ Builder zu verwechseln. Da die Version 4.0 erschien, während ich das Buch schrieb, und neue Eigenschaften brachte, habe ich die Quellen und Projektdateien auch für diesen bereitgestellt.

Es ist spannend zu sehen, ob diese Quellen, Jahre vor dem ersten Standard geschrieben, mit aktuellen Entwicklungssystemen noch nutzbar sind, und welche Anpassungen notwendig sind. Aber es ist ja gerade die Stärke von C++, dass auch ältere Sourcen noch in Systemen verwendet werden können.

## dBase Dateien mit C++ verarbeiten

Ich hatte es ja schon angekündigt, ich habe die dBase- Quellen aus dem obigen Archiv auf einen aktuellen Compiler migriert. Es war auch für mich interessant, ob man das ohne große Probleme hinbekommt, und welche Probleme generell auftreten. 

Die gute Nachricht, es geht relativ einfach, weil nur einige Verschärfungen dazukommen. Auffällig ist die Verwendung des "char*" Parameters, die man heute nicht mehr als "char*" macht, sondern "const char*" benutzen muss. Damit verhindert man die Änderung von Konstanten, insbesondere Zeichenketten, die vom Compiler erzeugt wurden. In die selbe Gruppe fallen die Kopierkonstruktoren, diese werden nur erkannt, wenn sie mit einem "const&" Parameter geschrieben werden. Daraus folgt auch die Notwendigkeit, auch einige Selektoren zu "const" zu machen, zumindest wenn sie in den Kopierkonstruktoren verwendet werden. Und am Ende ist noch die Benutzung dieser bösen und unsicheren Methoden wie "strcpy", die man aber zumindest in Visual Studio per "#define _CRT_SECURE_NO_WARNINGS" zuschalten kann. Dieses muss sich am Anfang einer Datei, bevor die erste Headerdatei kommt, stehen.

Am schwierigsten waren die nicht mehr vorhandenen Systemdatum- Klassen der DOS Zeit, aber es ist ja auch nur Routine, die neu geschrieben werden müssen. Und die Datei- Streams, die bei der Standardisierung noch mal überarbeitet und heute weniger Parameter haben. Ich habe hier einige Methoden, die hoffentlich mit C++98 verwendbar sind, ergänzt.

Und Last but not least waren die Anpassungen der Namen der Headerfiles. Ich habe mich jetzt entschieden, nur die C++ Namen, die zwingend geändert werden müssen (fstream.h - fstream), anzupassen, und habe immer explizit den Namensraum geöffnet. Das sollte man mit modernen Quellen nicht machen, aber als ich die ursprünglichen Quellen geschrieben habe, gab es keine Namensräume (die kamen auch erst um die Zeit herum auf), und schon gar keine Standardbibliothek. 

Also viel Spaß beim Ausprobieren, ich konnte die ausgegebene dbf- Datei mit Excel öffnen und alle Daten waren drin.

## Zinberechnungen mit C

Ich habe auch das Abschlussbeispiel aus dem C- Teil des Buches auf einen aktuellen Compiler übertragen. Zur Erinnerung, es geht da weniger um ein reines C- Programm, sondern um die Untermenge von C++, die sich auf die Sprache C bezieht. Deshalb waren das schon in den ursprünglichen cpp- Dateien, die mit C++ übersetzt wurden. Erwartungsgemäß ging das Anpassen hier wesentlich einfacher, es waren eigentlich nur kleine 3 Erweiterungen notwendig. Schließlich war C zu diesem Zeitpunkt bereits standardisiert (ANSI X3.159-1989 (C89), ISO/IEC 9899:1990 (C90)). Das zeigt, warum die enge Verwandtschaft von C und C++ für die Softwareentwicklung so wichtig ist, da in der Industrie, den Behörden und bei Banken und Versicherungen sehr viele wichtige Rechenprogramme in C geschrieben sind. Und es zeigt auch, wie wichtig ein unabhängiger Standardisierungsprozess ist.  

Ok, zu den notwendigen Änderungen. Zum einen das "#define _CRT_SECURE_NO_WARNINGS" um die unsicheren Methoden wie strchr und strncpy zu erlauben, diese werden zwar nicht im eigentlichen Berechnungsteil genutzt, aber beim Lesen der Eingabe, und der Behandlung des ',' als Dezimaltrenner. In genau dieser Methode taucht dann auch das bekannte Problem mit dem "char*" Parameterwieder auf, der für modernes C++ nicht mehr erlaubt sein kann, falls im Quelltext eine direkte Benutzung erfolgt. Dadurch ist dann auch die direkte Verwendung des Parameters ausgeschlossen, die soll ja durch das Erzwingen des "const" unterbunden werden. Es muss also eine Kopie in der Funktion erzeugt werden, die dann manipuliert werden kann. Ich habe da jetzt bewusst die C Methoden "malloc" und "free" verwendet, damit es C like bleibt.

Die letzte Änderung ist dann wirklich im Rechenteil, es wird heute ein expliziter cast in der Funktion "Rate()" benötigt, damit die "ZeitWertFaktor()" Funktion korrekt verwendet werden kann. 

